CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Have to enforce the role stuff for access control
-- Dunno if needed to be made a script or not
-- But just use insert normal insert or now

CREATE TABLE ROLES (
	ROLE_NAME VARCHAR(10) PRIMARY KEY,
	DESCRIPTION VARCHAR(100)
);

INSERT INTO ROLES(ROLE_NAME, DESCRIPTION) VALUES (
	'ADMIN',
	'TEST'
),(
    'USER', 
    'TEST');

CREATE TABLE ACCOUNT (
    ACCOUNT_ID uuid PRIMARY KEY,
    USERNAME VARCHAR(50) NOT NULL UNIQUE,
    EMAIL VARCHAR(100) NOT NULL UNIQUE,
    PASSWORD_HASH VARCHAR(255) NOT NULL,
    CREATED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    ACCOUNT_TYPE VARCHAR(20) NOT NULL CHECK (ACCOUNT_TYPE IN ('FREE', 'PAID', 'SYSADMIN')) DEFAULT 'FREE'
);

INSERT INTO ACCOUNT(ACCOUNT_ID, USERNAME, EMAIL, PASSWORD_HASH) VALUES (
	uuid_generate_v4(), 
	'admin', 
	'test@gmail.com',
	'password'
);

CREATE TABLE ACCOUNT_ROLE (
	ACCOUNT_ID uuid REFERENCES ACCOUNT(ACCOUNT_ID),
	ROLE_NAME VARCHAR(10) REFERENCES ROLES(ROLE_NAME),
	PRIMARY KEY (ACCOUNT_ID, ROLE_NAME)
);

INSERT INTO ACCOUNT_ROLE (ACCOUNT_ID, ROLE_NAME) VALUES (
    (SELECT ACCOUNT_ID FROM ACCOUNT WHERE USERNAME = 'admin'), 
    'ADMIN'
);

CREATE TABLE PAID_ACCOUNT (
    ACCOUNT_ID uuid PRIMARY KEY,
    STORAGE_LIMIT_GB INT NOT NULL DEFAULT 30,
    MONTHLY_COST DECIMAL(10,2) NOT NULL DEFAULT 10.00,
    START_DATE TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    RENEWAL_DATE TIMESTAMP NOT NULL,
    END_DATE TIMESTAMP, -- NULL if active
    STATUS VARCHAR(20) NOT NULL CHECK (STATUS IN ('ACTIVE', 'CANCELLED', 'EXPIRED')) DEFAULT 'ACTIVE',
    FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNT(ACCOUNT_ID) ON DELETE CASCADE
);

CREATE TABLE FREE_ACCOUNT (
    ACCOUNT_ID uuid PRIMARY KEY,
    STORAGE_LIMIT_GB INT NOT NULL DEFAULT 2,
    FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNT(ACCOUNT_ID) ON DELETE CASCADE
);

-- Folder hierarchy for user storage
CREATE TABLE FOLDER (
    FOLDER_ID uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    NAME VARCHAR(255) NOT NULL,
    ACCOUNT_ID uuid NOT NULL,
    PARENT_FOLDER_ID uuid,
    CREATED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNT(ACCOUNT_ID) ON DELETE CASCADE,
    FOREIGN KEY (PARENT_FOLDER_ID) REFERENCES FOLDER(FOLDER_ID) ON DELETE CASCADE
);

-- Optional indexes for faster lookups on folders
CREATE INDEX IF NOT EXISTS idx_folder_account ON FOLDER(ACCOUNT_ID);
CREATE INDEX IF NOT EXISTS idx_folder_parent ON FOLDER(PARENT_FOLDER_ID);

CREATE TABLE SYSADMIN_ACCOUNT (
    ACCOUNT_ID uuid PRIMARY KEY,
    -- Future: Add admin-specific attributes here if needed
    -- Examples: access_level, permissions, admin_settings, etc.
    FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNT(ACCOUNT_ID) ON DELETE CASCADE
);

CREATE TABLE ERASURE_PROFILE(
    ERASURE_ID VARCHAR(50) PRIMARY KEY NOT NULL CHECK (ERASURE_ID IN ('LOW', 'MEDIUM', 'HIGH')) DEFAULT 'MEDIUM',
    k INT NOT NULL,
    m INT NOT NULL,
    bytes INT NOT NULL,
    NOTES TEXT
);

INSERT INTO ERASURE_PROFILE (ERASURE_ID, k, m, bytes, NOTES) VALUES
('LOW', 6, 1, 1024, 'Low redundancy'),
('MEDIUM', 5, 2, 2048, 'Medium redundancy'),
('HIGH', 4, 3, 4096, 'High redundancy');

CREATE TABLE ACCOUNT_ERASURE (
    ACCOUNT_ID uuid PRIMARY KEY,
    ERASURE_ID VARCHAR(50) NOT NULL,
    FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNT(ACCOUNT_ID) ON DELETE CASCADE,
    FOREIGN KEY (ERASURE_ID) REFERENCES ERASURE_PROFILE(ERASURE_ID)
);

CREATE TABLE FILE_OBJECTS (
    FILE_ID uuid PRIMARY KEY,
    ACCOUNT_ID uuid NOT NULL,
    FILE_NAME VARCHAR(255) NOT NULL,
    FILE_SIZE BIGINT NOT NULL,
    UPLOADED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    LOGICAL_PATH TEXT NOT NULL,
    FOLDER_ID uuid,
    UPDATED_AT TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNT(ACCOUNT_ID),
    FOREIGN KEY (FOLDER_ID) REFERENCES FOLDER(FOLDER_ID) ON DELETE SET NULL
);

CREATE TABLE FILE_VERSIONS (
    VERSION_ID uuid PRIMARY KEY,
    FILE_ID uuid NOT NULL,
    ERASURE_ID VARCHAR(50) NOT NULL,
    BYTES BIGINT NOT NULL,
    CONTENT_HASH VARCHAR(64) NOT NULL,
    UPLOADED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (FILE_ID) REFERENCES FILE_OBJECTS(FILE_ID) ON DELETE CASCADE,
    FOREIGN KEY (ERASURE_ID) REFERENCES ERASURE_PROFILE(ERASURE_ID)
);

CREATE TABLE FILE_SEGMENTS (
    SEGMENT_ID uuid PRIMARY KEY,
    VERSION_ID uuid NOT NULL,
    ERASURE_ID VARCHAR(50) NOT NULL,
    NUM_SEGMENT INT NOT NULL,
    BYTES BIGINT NOT NULL,
    CONTENT_HASH VARCHAR(64) NOT NULL,
    STORED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (VERSION_ID) REFERENCES FILE_VERSIONS(VERSION_ID) ON DELETE CASCADE,
    FOREIGN KEY (ERASURE_ID) REFERENCES ERASURE_PROFILE(ERASURE_ID)
);

CREATE TABLE FILE_FRAGMENTS (
    FRAGMENT_ID uuid PRIMARY KEY,
    SEGMENT_ID uuid NOT NULL,
    NUM_FRAGMENT INT NOT NULL,
    BYTES BIGINT NOT NULL,
    CONTENT_HASH VARCHAR(64) NOT NULL,
    STORED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (SEGMENT_ID) REFERENCES FILE_SEGMENTS(SEGMENT_ID) ON DELETE CASCADE
);

CREATE TABLE NODE (
    NODE_ID uuid PRIMARY KEY,
    API_ENDPOINT VARCHAR(255) NOT NULL,
    NODE_ROLE VARCHAR(50) NOT NULL CHECK (NODE_ROLE IN ('STORAGE', 'MASTER', 'FOLLOWER')),
    HOSTNAME VARCHAR(255) NOT NULL,
    IS_ACTIVE BOOLEAN NOT NULL DEFAULT TRUE,
    UPTIMED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    HEARTBEAT_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    LATENCY_MS INT NOT NULL DEFAULT 0
);

CREATE TABLE NODE_HEARTBEAT(
    HEARTBEAT_ID uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    NODE_ID uuid NOT NULL,
    UPTIMED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    HEARTBEAT_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    LATENCY_MS INT NOT NULL DEFAULT 0,
    FOREIGN KEY (NODE_ID) REFERENCES NODE(NODE_ID)
);

CREATE TABLE NODE_CAPACITY (
    NODE_ID uuid PRIMARY KEY,
    TOTAL_BYTES BIGINT NOT NULL,
    USED_BYTES BIGINT NOT NULL,
    AVAILABLE_BYTES BIGINT NOT NULL,
    UPDATED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (NODE_ID) REFERENCES NODE(NODE_ID)
);

CREATE TABLE FRAGMENT_LOCATION (
    FRAGMENT_ID uuid PRIMARY KEY,
    NODE_ID uuid NOT NULL,
    FRAGMENT_ADDRESS VARCHAR(255) NOT NULL,
    STORED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    BYTES BIGINT NOT NULL,
    STATUS VARCHAR(20) NOT NULL CHECK (STATUS IN ('ACTIVE', 'INACTIVE')) DEFAULT 'ACTIVE',
    LAST_CHECKED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (FRAGMENT_ID) REFERENCES FILE_FRAGMENTS(FRAGMENT_ID) ON DELETE CASCADE,
    FOREIGN KEY (NODE_ID) REFERENCES NODE(NODE_ID) ON DELETE CASCADE
);

CREATE TABLE FILE_KEYS (
    KEY_ID uuid PRIMARY KEY,
    VERSION_ID uuid NOT NULL,
    ENCRYPTION_KEY VARCHAR(512) NOT NULL,
    KEY_CREATED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (VERSION_ID) REFERENCES FILE_VERSIONS(VERSION_ID) ON DELETE CASCADE
);

CREATE TABLE KEY_SHARE(
    KEY_ID uuid PRIMARY KEY,
    KEY_SHARE_ID BIGINT NOT NULL,
    NODE_ID uuid NOT NULL,
    SHARE_BYTES BIGINT NOT NULL,
    SHARE_ADDRESS VARCHAR(255) NOT NULL,
    CREATED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (KEY_ID) REFERENCES FILE_KEYS(KEY_ID) ON DELETE CASCADE,
    FOREIGN KEY (NODE_ID) REFERENCES NODE(NODE_ID) ON DELETE CASCADE
);

CREATE TABLE REPAIR_JOBS (
    JOB_ID uuid PRIMARY KEY,
    VERSION_ID uuid NOT NULL,
    REASON VARCHAR(255) NOT NULL,
    STATUS VARCHAR(20) NOT NULL CHECK (STATUS IN ('PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED')),
    CREATED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    STARTED_AT TIMESTAMP,
    COMPLETED_AT TIMESTAMP,
    FOREIGN KEY (VERSION_ID) REFERENCES FILE_VERSIONS(VERSION_ID) ON DELETE CASCADE
);

CREATE TABLE WORKERS(
    WORKER_ID uuid PRIMARY KEY,
    JOB_ID uuid NOT NULL,
    FRAGMENT_ID uuid NOT NULL,
    NODE_ID uuid NOT NULL,
    STATUS VARCHAR(20) NOT NULL CHECK (STATUS IN ('ASSIGNED', 'IN_PROGRESS', 'COMPLETED', 'FAILED')),
    ASSIGNED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    COMPLETED_AT TIMESTAMP,
    FOREIGN KEY (JOB_ID) REFERENCES REPAIR_JOBS(JOB_ID) ON DELETE CASCADE,
    FOREIGN KEY (FRAGMENT_ID) REFERENCES FILE_FRAGMENTS(FRAGMENT_ID) ON DELETE CASCADE,
    FOREIGN KEY (NODE_ID) REFERENCES NODE(NODE_ID) ON DELETE CASCADE
);

CREATE INDEX idx_file_objects_account_id ON FILE_OBJECTS(ACCOUNT_ID);
CREATE INDEX idx_file_versions_file_id ON FILE_VERSIONS(FILE_ID);
CREATE INDEX idx_file_segments_version_id ON FILE_SEGMENTS(VERSION_ID);
CREATE INDEX idx_file_fragments_segment_id ON FILE_FRAGMENTS(SEGMENT_ID);
CREATE INDEX idx_fragment_location_node_id ON FRAGMENT_LOCATION(NODE_ID);
CREATE INDEX idx_file_keys_version_id ON FILE_KEYS(VERSION_ID);
CREATE INDEX idx_key_share_node_id ON KEY_SHARE(NODE_ID);
CREATE INDEX idx_repair_jobs_version_id ON REPAIR_JOBS(VERSION_ID);
CREATE INDEX idx_workers_job_id ON WORKERS(JOB_ID);
CREATE INDEX idx_workers_fragment_id ON WORKERS(FRAGMENT_ID);
CREATE INDEX idx_workers_node_id ON WORKERS(NODE_ID);

-- Password Reset Tokens (for future email-based recovery, WIP more features needed to be implemented)
CREATE TABLE PASSWORD_RESET_TOKENS (
    TOKEN_ID uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    ACCOUNT_ID uuid NOT NULL,
    TOKEN_HASH VARCHAR(255) NOT NULL UNIQUE,
    EXPIRES_AT TIMESTAMP NOT NULL,
    USED_AT TIMESTAMP,
    CREATED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNT(ACCOUNT_ID) ON DELETE CASCADE
);

CREATE INDEX idx_reset_token_hash ON PASSWORD_RESET_TOKENS(TOKEN_HASH);
CREATE INDEX idx_reset_token_account ON PASSWORD_RESET_TOKENS(ACCOUNT_ID);
CREATE INDEX idx_reset_token_expires ON PASSWORD_RESET_TOKENS(EXPIRES_AT);

-- Activity Log for audit trail
CREATE TABLE ACTIVITY_LOG (
    ACTIVITY_ID uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    ACCOUNT_ID uuid NOT NULL,
    ACTION_TYPE VARCHAR(50) NOT NULL,
    RESOURCE_TYPE VARCHAR(50),
    RESOURCE_ID uuid,
    IP_ADDRESS VARCHAR(45),
    USER_AGENT TEXT,
    DETAILS JSONB,
    CREATED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNT(ACCOUNT_ID) ON DELETE CASCADE
);

CREATE INDEX idx_activity_account ON ACTIVITY_LOG(ACCOUNT_ID);
CREATE INDEX idx_activity_action ON ACTIVITY_LOG(ACTION_TYPE);
CREATE INDEX idx_activity_created ON ACTIVITY_LOG(CREATED_AT);
CREATE INDEX idx_activity_resource ON ACTIVITY_LOG(RESOURCE_TYPE, RESOURCE_ID);
CREATE INDEX idx_activity_account_date ON ACTIVITY_LOG(ACCOUNT_ID, CREATED_AT);

-- Recycle Bin Tables
-- Description: Soft delete system for files and folders with 30-day retention
-- Date: 2025-12-08

-- Create Recycle Bin table for deleted files and folders
CREATE TABLE IF NOT EXISTS recycle_bin (
    bin_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    account_id UUID NOT NULL REFERENCES account(account_id) ON DELETE CASCADE,
    resource_type VARCHAR(10) NOT NULL CHECK (resource_type IN ('FILE', 'FOLDER')),
    resource_id UUID NOT NULL, -- References file_objects.file_id or folder.folder_id
    original_name VARCHAR(255) NOT NULL,
    original_path TEXT, -- Store the full path for context
    original_size BIGINT, -- For files only, NULL for folders
    deleted_by UUID NOT NULL REFERENCES account(account_id) ON DELETE CASCADE,
    deleted_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT (CURRENT_TIMESTAMP + INTERVAL '30 days'),
    deletion_reason VARCHAR(100), -- 'USER_DELETE', 'ADMIN_DELETE', 'AUTO_CLEANUP', etc.
    bin_metadata JSONB, -- Store additional context like parent folder info, file type, etc.
    is_recovered BOOLEAN NOT NULL DEFAULT FALSE,
    recovered_at TIMESTAMP WITH TIME ZONE,
    recovered_by UUID REFERENCES account(account_id)
);

-- Create indexes for better performance on bin operations
CREATE INDEX IF NOT EXISTS idx_recycle_bin_account ON recycle_bin(account_id);
CREATE INDEX IF NOT EXISTS idx_recycle_bin_deleted_at ON recycle_bin(deleted_at);
CREATE INDEX IF NOT EXISTS idx_recycle_bin_expires_at ON recycle_bin(expires_at);
CREATE INDEX IF NOT EXISTS idx_recycle_bin_resource ON recycle_bin(resource_type, resource_id);
CREATE INDEX IF NOT EXISTS idx_recycle_bin_recovered ON recycle_bin(is_recovered);

-- File and Folder Sharing Tables
-- Description: Adds tables for file/folder sharing with one-time passwords and user sharing
-- Date: 2025-12-08

-- Create File Shares table
CREATE TABLE IF NOT EXISTS file_shares (
    share_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    file_id UUID NOT NULL REFERENCES file_objects(file_id) ON DELETE CASCADE,
    shared_by UUID NOT NULL REFERENCES account(account_id) ON DELETE CASCADE,
    shared_with UUID REFERENCES account(account_id) ON DELETE CASCADE, -- NULL for public links
    share_token VARCHAR(255), -- NULL for direct user shares, NOT NULL for public links
    password_hash VARCHAR(255), -- One-time password hash
    permissions VARCHAR(20) NOT NULL DEFAULT 'VIEW' CHECK (permissions IN ('VIEW', 'DOWNLOAD')),
    expires_at TIMESTAMP WITH TIME ZONE,
    used_at TIMESTAMP WITH TIME ZONE, -- When password was used
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    is_active VARCHAR(10) NOT NULL DEFAULT 'ACTIVE' CHECK (is_active IN ('ACTIVE', 'EXPIRED', 'REVOKED'))
);

-- Create Folder Shares table
CREATE TABLE IF NOT EXISTS folder_shares (
    share_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    folder_id UUID NOT NULL REFERENCES folder(folder_id) ON DELETE CASCADE,
    shared_by UUID NOT NULL REFERENCES account(account_id) ON DELETE CASCADE,
    shared_with UUID REFERENCES account(account_id) ON DELETE CASCADE, -- NULL for public links
    share_token VARCHAR(255), -- NULL for direct user shares, NOT NULL for public links
    password_hash VARCHAR(255), -- One-time password hash
    permissions VARCHAR(20) NOT NULL DEFAULT 'VIEW' CHECK (permissions IN ('VIEW', 'DOWNLOAD')),
    expires_at TIMESTAMP WITH TIME ZONE,
    used_at TIMESTAMP WITH TIME ZONE, -- When password was used
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    is_active VARCHAR(10) NOT NULL DEFAULT 'ACTIVE' CHECK (is_active IN ('ACTIVE', 'EXPIRED', 'REVOKED'))
);

-- Create Share Access Log table
CREATE TABLE IF NOT EXISTS share_access_log (
    access_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    share_id UUID NOT NULL, -- Can reference file_shares or folder_shares
    share_type VARCHAR(10) NOT NULL CHECK (share_type IN ('FILE', 'FOLDER')),
    accessed_by UUID REFERENCES account(account_id), -- NULL for anonymous access
    ip_address VARCHAR(45),
    user_agent TEXT,
    action VARCHAR(50) NOT NULL CHECK (action IN ('VIEW', 'DOWNLOAD', 'PASSWORD_ATTEMPT')),
    success VARCHAR(10) NOT NULL DEFAULT 'SUCCESS' CHECK (success IN ('SUCCESS', 'FAILED')),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes for better performance on sharing tables
CREATE INDEX IF NOT EXISTS idx_file_shares_token ON file_shares(share_token);
CREATE INDEX IF NOT EXISTS idx_file_shares_shared_by ON file_shares(shared_by);
CREATE INDEX IF NOT EXISTS idx_file_shares_shared_with ON file_shares(shared_with);
CREATE INDEX IF NOT EXISTS idx_file_shares_file_id ON file_shares(file_id);
CREATE INDEX IF NOT EXISTS idx_file_shares_created ON file_shares(created_at);

CREATE INDEX IF NOT EXISTS idx_folder_shares_token ON folder_shares(share_token);
CREATE INDEX IF NOT EXISTS idx_folder_shares_shared_by ON folder_shares(shared_by);
CREATE INDEX IF NOT EXISTS idx_folder_shares_shared_with ON folder_shares(shared_with);
CREATE INDEX IF NOT EXISTS idx_folder_shares_folder_id ON folder_shares(folder_id);
CREATE INDEX IF NOT EXISTS idx_folder_shares_created ON folder_shares(created_at);

CREATE INDEX IF NOT EXISTS idx_share_access_log_share_id ON share_access_log(share_id);
CREATE INDEX IF NOT EXISTS idx_share_access_log_accessed_by ON share_access_log(accessed_by);
CREATE INDEX IF NOT EXISTS idx_share_access_log_created ON share_access_log(created_at);

-- Additional constraint for share_token uniqueness where not null (for public links)
CREATE UNIQUE INDEX IF NOT EXISTS idx_file_shares_token_unique ON file_shares(share_token) WHERE share_token IS NOT NULL;
CREATE UNIQUE INDEX IF NOT EXISTS idx_folder_shares_token_unique ON folder_shares(share_token) WHERE share_token IS NOT NULL;
